▶ this
		클래스 선언시 내부적으로 선언되어 생성된다.
		클래스는 선언시 한번의 메소드를 선언하는데 그 메소드는
		여러 객체의 공통적인 행동을 정의하고 있다. 즉, 한번의 선언으로
		여러 객체를 다루어야 한다. 그렇기 때문에 메소드 내에서 객체의 필드를
		사용하고자 할 때 어떤 객체의 필드인지를 구분할 수 없다.
		따라서 객체를 생성하거나 혹은 객체 . 을 찍고 필드에 접근하는
		순간 그 객체를 this라는 변수가 받는다. 결과적으로 클래스
		선언시 this.필드명 으로 접근하면 여러 객체도 하나의 메소드에서
		다룰 수 있게 된다.
		this : 객체 구별용 변수

▶ 생성자의 목적
		1. 클래스의 필드를 똑같이 복사해서 메모리에 할당해주고 할당된
		필드의 주소값을 가지고 온다. 이 주소값을 객체에 넣어놓고 사용한다.(객체화의 목적)
		
		2. 생성자는 호출시 내부의 내용을 모두 수행한다.(초기화의 목적)

▶ 다형성(Polymorphism) : 형태가 다양한 성질
		1. Overloading(오버로딩)
				같은 이름의 메소드를 넘쳐서(여러개) 불러오는(선언하는) 기법
				매개변수의 개수 혹은 타입이 다르면 같은 이름의 메소드로
				여러개 선언할 수 있다. 이름이 아닌 매개변수로 구별하기 때문이다.
				오버로딩된 메소드 사용시, 전달된 값의 타입 혹은 개수로 구분하여
				알맞은 메소드가 자동으로 호출된다.

▶ 클래스 배열
		객체를 여러개 선언해야 하는 경우 배열 타입으로 한번에 선언 후 사용
		각 객체는 규칙성이 없기 때문에 규칙성을 부여하기 위해서 사용한다.

▶ 클래스 배열 선언
		클래스명[] 배열명 = {
				new 생성자(),
				new 생성자(),
				...
		};

		클래스명[] 배열명 = new 배열명[칸수];
		--> 초기값이 배열에 채워지는데 클래스의 초기값은
			null(:주소값의 초기값)로 채워진다.
		String[] a = null; 가능
		주소값이 들어갈 수 있는 곳에는 null가능

		이때 null인데 이것으로 뭔가를 할려고 하면
		NullPointException(오류)가 발생한다.

▶ 클래스 배열 사용
		배열명[idx] 방이 객체를 의미하게 된다.
	
		배열명[idx].변수
		배열명[idx].메소드()

















